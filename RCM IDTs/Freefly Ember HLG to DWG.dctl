// Written by Thatcher Freeman
// Fit to exposure charts shot on an Ember with HLG gamma.
// clang-format off
DEFINE_UI_PARAMS(input_tone_curve, Input Transfer Function, DCTLUI_COMBO_BOX, 0, {EMBER_HLG, EMBER_LINEAR}, {Ember HLG Beta, Linear})
DEFINE_UI_PARAMS(output_tone_curve, Output Transfer Function, DCTLUI_COMBO_BOX, 0, {DI, LINEAR}, {DaVinci Intermediate, Linear})
DEFINE_UI_PARAMS(output_color_gamut, Output Color Gamut, DCTLUI_COMBO_BOX, 0, {DWG, NATIVE}, {DaVinci Wide Gamut, Camera Native})

// clang-format on

__DEVICE__ float powf(float base, float exp) {
    return _copysignf(_powf(_fabs(base), exp), base);
}

__DEVICE__ float ember_hlg_to_linear(float x) {

    const float slope = 2.818105697631836f;
    const float offset = 0.0f;
    const float offset2 = -0.004920648410916328f;
    const float power = 0.4226517677307129f;
    const float cut = 0.11711454391479492f;
    const float a = 0.1274157464504242f;
    const float b = 0.5203865170478821f;
    const float c = 0.7146257162094116f;
    const float mid_gray_scaling = 4.307229518890381f;

    const float log_cut = powf(cut * slope + offset, power) + offset2;

    float output;
    if (x < log_cut) {
        output = (powf(x - offset2, 1.0f / power) - offset) / slope;
    } else {
        output = (_expf((x - c) / a) + b) * cut;
    }
    output *= mid_gray_scaling;
    return output;
}

__DEVICE__ float linear_to_di(float x) {
    const float a = 0.0075f;
    const float b = 7.0f;
    const float c = 0.07329248f;
    const float m = 10.44426855f;
    const float lin_cut = 0.00262409f;
    // const float log_cut = 0.02740668f;

    if (x > lin_cut) {
        return (_log2f(x + a) + b) * c;
    } else {
        return x * m;
    }
}

__DEVICE__ float3 mv_33_3(float mat[3][3], float3 v) {
    float3 out = make_float3(mat[0][0] * v.x + mat[0][1] * v.y + mat[0][2] * v.z,
                             mat[1][0] * v.x + mat[1][1] * v.y + mat[1][2] * v.z,
                             mat[2][0] * v.x + mat[2][1] * v.y + mat[2][2] * v.z);
    return out;
}

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B) {
    float3 rgb;
    if (input_tone_curve == EMBER_HLG) {
        rgb = make_float3(ember_hlg_to_linear(p_R), ember_hlg_to_linear(p_G), ember_hlg_to_linear(p_B));
        // Map 37% input to mid gray.
        const float gain = 0.18f / 0.15f;
        rgb *= gain;
    } else if (input_tone_curve == EMBER_LINEAR) {
        rgb = make_float3(p_R, p_G, p_B);
    }

    // Assumed Rec2020 primaries
    float matrix[3][3] = {
        {0.892112120946446f, 0.024369175871217f, 0.083518703182337f},
        {0.032616601764085f, 0.786137516904113f, 0.181245881331803f},
        {0.069977051185634f, 0.104749491903827f, 0.825273456910539f},
    };

    float3 rgb2;
    if (output_color_gamut == DWG) {
        rgb2 = mv_33_3(matrix, rgb);
    } else if (output_color_gamut == NATIVE) {
        rgb2 = rgb;
    }

    float3 out;
    if (output_tone_curve == DI) {
        out = make_float3(linear_to_di(rgb2.x), linear_to_di(rgb2.y), linear_to_di(rgb2.z));
    } else if (output_tone_curve == LINEAR) {
        out = rgb2;
    }
    return out;
}
