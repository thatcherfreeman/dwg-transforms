__DEVICE__ inline float dot_product(float3 a, float3 b) {
    return a.x * b.x + a.y * b.y + a.z * b.z;
}

// if c = mix(a, b, t), then a = unmixf(b, c, t) and b = unmixf(a, c, (1-t))
__DEVICE__ float unmixf(float b, float c, float t) {
    if (t == 1) {
        return 0;
    } else {
        return (c - b * t) / (1 - t);
    }
}

__DEVICE__ inline float3 unmixf3(float3 b, float3 c, float t) {
    float3 output = make_float3(
        unmixf(b.x, c.x, t),
        unmixf(b.y, c.y, t),
        unmixf(b.z, c.z, t)
    );
    return output;
}


__DEVICE__ float logv3_to_linear(float invec)
{
    // This function is probably bad
    // TODO: Make a better inverse of the linear to logv3 function
    float u = _exp2f((invec / 0.125) - 8.0);
    float x = 1.1612159730893894;
    float y = 0.6090138106343165;
    float out = _powf(u, _mix(x, y, invec));
    return out;
}

__DEVICE__ float3 resaturate(float3 invec) {
    // as desaturate is a linear mixture between the saturated vector and monochrome
    // the desaturated vector should have the same luminance.
    float p = dot_product(invec, make_float3(0.2126, 0.7152, 0.0722));
    float3 monochrome = make_float3(p, p, p);

    float o = 0.16667 * _logf(p) + 1.0;

    float3 output = unmixf3(monochrome, invec, 1.0 - o);
    return output;
}

__DEVICE__ float linear_to_dwg(float x)
{
    const float a = 0.0075f;
    const float b = 7.0f;
    const float c = 0.07329248f;
    const float m = 10.44426855f;
    const float lin_cut = 0.00262409f;
    const float log_cut = 0.02740668f;

    if (x > lin_cut) {
        return (_log2f(x + a) + b) * c;
    } else {
        return x * m;
    }
}

// Used values calculated from http://color.support/colorspacecalculator.html
// Assumed Rec709 primaries (after resaturation), to DWG
__CONSTANT__ float matrix[9] = {
    0.562767,  0.323517,  0.113716,
    0.077755,  0.749577,  0.172668,
    0.064669,  0.191999,  0.743332,
};

__DEVICE__ float3 transform(int p_Width, int p_Height, int p_X, int p_Y, float p_R, float p_G, float p_B)
{
    float r = logv3_to_linear(p_R);
    float g = logv3_to_linear(p_G);
    float b = logv3_to_linear(p_B);

    float3 resaturated = resaturate(make_float3(r, g, b));
    r = resaturated.x;
    g = resaturated.y;
    b = resaturated.z;

    float r2 = ( matrix[0] * r) + ( matrix[1] * g) + ( matrix[2] * b);
    float g2 = ( matrix[3] * r) + ( matrix[4] * g) + ( matrix[5] * b);
    float b2 = ( matrix[6] * r) + ( matrix[7] * g) + ( matrix[8] * b);

    float r3 = linear_to_dwg(r2);
    float g3 = linear_to_dwg(g2);
    float b3 = linear_to_dwg(b2);

    float3 res = make_float3(r3, g3, b3);
    return res;
}